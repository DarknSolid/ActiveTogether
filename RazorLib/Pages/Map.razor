@using GoogleMapsComponents
@using GoogleMapsComponents.Maps
@using System.Diagnostics
@using ModelLib.ApiDTOs
@using ModelLib.DTOs.DogPark
@using RazorLib.AbstractClasses
@using RazorLib.Components
@using RazorLib.Interfaces
@using RazorLib.Models
@inject IDialogService DialogService
@inject MapSearcher MapSearcher
@inject ISessionStorage SessionStorage

<PageTitle>Map</PageTitle>

<h1>Google Map Markers</h1>

<MudToggleIconButton Toggled="@ShouldDisplayRoadMap" ToggledChanged="OnMapTypeChanged"
                     Icon="@Icons.Filled.SatelliteAlt" Title="Off"
                     ToggledIcon="@Icons.Outlined.SatelliteAlt" ToggledTitle="On" />

<GoogleMap @ref="@map" Id="map" Options="@mapOptions" OnAfterInit="@(async () => await OnAfterInitAsync())"></GoogleMap>


@code {
    public bool ShouldDisplayRoadMap { get; set; }
    private GoogleMap map = default!;
    private MapOptions mapOptions = default!;

    [Parameter]
    public MapFilterDTO MapFilterDTO { get; set; }

    [Parameter]
    public Action<int> OnDogParkPressed { get; set; }


    private MapTypeId GetCurrentMapType()
    {
        return ShouldDisplayRoadMap ? MapTypeId.Roadmap : MapTypeId.Satellite;
    }

    protected override void OnInitialized()
    {
        ShouldDisplayRoadMap = true;

        mapOptions = new MapOptions()
            {
                Zoom = 13,
                Center = new LatLngLiteral()
                {
                    Lat = 55.6570832,
                    Lng = 12.5937645
                },
                MapTypeId = GetCurrentMapType(),
                DisableDefaultUI = true,
                GestureHandling = "greedy",
            };

        if (MapFilterDTO == null)
        {
            MapFilterDTO = new MapFilterDTO();
        }
    }

    private async Task OnAfterInitAsync()
    {
        //TODO zoom_changed event or just bounds_changed event instead of drag and zoom
        MapSearcher.SetMap(map);
        if (await SessionStorage.Exists(nameof(mapOptions)))
        {
            mapOptions = await SessionStorage.GetItem<MapOptions>(nameof(mapOptions));
            await map.InteropObject.SetCenter(mapOptions.Center);
            await map.InteropObject.SetZoom(Convert.ToDouble(mapOptions.Zoom));
            await map.InteropObject.SetMapTypeId(mapOptions.MapTypeId);
        } 
        await map.InteropObject.AddListener("dragend", OnDragEnd);
        await map.InteropObject.AddListener("zoom_changed", OnDragEnd);
    }

    public async void OnMapTypeChanged(bool toggled)
    {
        ShouldDisplayRoadMap = !ShouldDisplayRoadMap;
        await MapSearcher.ToggleMarkers();
        await map.InteropObject.SetMapTypeId(GetCurrentMapType());
        await SaveMapStateAsync();
    }

    private async void OnDragEnd()
    {
        await UpdateMap();
    }

    private async Task UpdateMap()
    {
        await SaveMapStateAsync();

        var newMapMarkers = await MapSearcher.UpdateMapIcons(MapFilterDTO);
        if (newMapMarkers == null)
        {
            return;
        }
        foreach ((Marker dogPark, int id) in newMapMarkers.DogParks)
        {
            await dogPark.AddListener("click", () =>
            {
                OnDogParkPressed(id);
            });
        }
    }

    private async Task SaveMapStateAsync()
    {
        int? newZoom = Convert.ToInt32(await map.InteropObject.GetZoom());
        var newMapOptions = new MapOptions
            {
                Center = await map.InteropObject.GetCenter(),
                Zoom = newZoom,
                MapTypeId = GetCurrentMapType(),
                DisableDefaultUI = mapOptions.DisableDefaultUI,
                GestureHandling = mapOptions.GestureHandling

            };
        await SessionStorage.SetItem(nameof(mapOptions), newMapOptions);
    }
}